#!/usr/bin/env python3

import sys
import re

AUTOGENERATED_WARNING = """\
//////
// AUTOGENERATED FILE DO NOT EDIT
//////
"""

EXPR_VISITOR_TEMPLATE = """
/**
 A type that will transform some `Expr` into a `Result`; usually this
 means a recursive walk of nested `Expr`s.
 */
protocol ExprVisitor
{{
    /** The product of this visitor's transform. */
    associatedtype Result
    {method_decls}
}}
"""

EXPR_STRUCT_TEMPLATE = """
struct {name} : Expr
{{
    {prop_decls}
    
    func accept<V : ExprVisitor>(visitor: V) -> V.Result
    {{
        return visitor.visit(self)
    }}
}}
"""

EXPR_PROTOCOL_DEF = """
/** A syntactic element in a Lox program. */
protocol Expr
{
    /** Allow the given visitor to transform this value. */
    func accept<V : ExprVisitor>(visitor: V) -> V.Result
}
"""

def parse_descriptions(config_lines):
    descriptions = []
    for line in config_lines:
        name, properties = (s.strip() for s in line.split('~'))
        properties = (s.strip() for s in properties.split(','))
        descriptions.append((name, properties))
    return descriptions

def build_expr_struct(name, properties):
    #TODO: Add doc strings to the types
    prop_decls = [f"let {prop}" for prop in properties]
    return EXPR_STRUCT_TEMPLATE.format(name=name,
                                       prop_decls='\n    '.join(prop_decls))

def process_generic_args(typename):
    pattern = r"(?P<name>\w+)(?P<args><\w+( ?: ?\w+)?(, \w+( : \w+)?)*>)"
    full_match = re.fullmatch(pattern, typename)
    if not full_match:
        return (typename, "")
    
    # Drop angle brackets and separate
    args = [arg.strip() for arg in full_match.group("args")[1:-1].split(',')]
    inheritance_pattern = r"(?P<argname>\w+)( ?: ?\w+)?"
    # Extract bare names
    arg_names = [re.fullmatch(inheritance_pattern, arg).group("argname") 
                    for arg in args]
    arg_list = f"<{', '.join(arg_names)}>"
    
    return (f"{full_match.group('name')}{arg_list}", arg_list)

def build_exprvisitor_protocol(expr_typenames):
    method_decls = []
    for typename in expr_typenames:
        type, generic_args = process_generic_args(typename)
        parameter = typename.split('<')[0].lower()
        method_decl = f"func visit{generic_args}(_ {parameter}: {type}) -> Result"
        method_decls.append(method_decl)

    return EXPR_VISITOR_TEMPLATE.format(method_decls='\n    '.join(method_decls))

def main(config, output):
    with open(config, 'r') as config_file:
        descriptions = parse_descriptions(config_file.readlines())

    structs = [build_expr_struct(name, properties)
                for (name, properties) in descriptions]

    typenames = map(lambda pair: pair[0], descriptions)
    expr_visitor = build_exprvisitor_protocol(typenames)

    with open(output, 'w') as output_file:
        output_file.write(f"{AUTOGENERATED_WARNING}")
        output_file.write(f"{expr_visitor}")
        output_file.write(f"{EXPR_PROTOCOL_DEF}")
        for struct in structs:
            output_file.write(f"{struct}")        

if __name__ == '__main__':
    if len(sys.argv) != 3:
        invoked_name = sys.argv[0].split('/')[-1]
        print(f"Usage: {invoked_name} config_file output_file")
        sys.exit(1)
    main(sys.argv[1], sys.argv[2])
