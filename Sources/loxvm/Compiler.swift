import Foundation
import loxvm_object

/**
 Translator from a token stream to bytecode stored in a `Chunk`, using a `Scanner` as a helper
 to get tokens from the provided source.
 */
class Compiler
{
    /** Description of current parsing with regard to error tokens and reporting. */
    fileprivate enum State
    {
        /** Compilation is proceeding without error. */
        case normal
        /**
         Compilation is continuing but an error was previously encountered. We will report as
         many further errors as possible, but discard generated bytecode without executing it.
         */
        case error
        /**
         We've just encountered an error and parsing is in an indeterminate state; error
         messages will be suppressed until we reach a synchronization point.
         */
        case panic
    }
    private var state: State = .normal

    private let scanner: Scanner
    private let strings: HashTable
    private let identifiers: HashTable
    private let allocator: MemoryManager
    private lazy var stringCompiler = StringCompiler(allocate: { [allocator] in allocator.allocateBuffer(of: UInt8.self, count: $0) },
                                                      destroy: { [allocator] in allocator.destroyBuffer($0) })
    private var currentToken: Token = .dummy
    private var previousToken: Token = .dummy

    private var chunk: Chunk = Chunk()

    /**
     Create a compiler to operate on the given source, obtaining any neccessary heap memory
     from the provided allocator.
     */
    init(source: String, stringsTable: HashTable, allocator: MemoryManager)
    {
        self.scanner = Scanner(source: source)
        self.strings = stringsTable
        self.identifiers = HashTable(manager: allocator)
        self.allocator = allocator
    }
}

extension Compiler
{
    /** Translate the source into bytecode. */
    func compile() -> Chunk?
    {
        self.advance()

        while !self.match(.EOF) {
            self.declaration()
        }

        guard self.state == .normal else {
            return nil
        }

        self.end()

        return self.chunk
    }

    private func end()
    {
        self.emitReturn()

        #if DEBUG_PRINT_CHUNK
        if self.state == .normal {
            disassemble(self.chunk, name: "generated_code")
        }
        #endif
    }

    /**
     Store the current token, then move past any error tokens, reporting them as appropriate.
     */
    private func advance()
    {
        self.previousToken = self.currentToken

        self.currentToken = self.scanner.scanToken()
        while self.currentToken.kind == .error {
            self.reportErrorAtCurrent(message: self.currentToken.lexeme)
            self.currentToken = self.scanner.scanToken()
        }
    }

    /**
     Check for a particular token kind at the current position, reporting an error if it is not
     found.
     */
    private func mustConsume(_ kind: Token.Kind, message: String)
    {
        guard self.currentToken.kind == kind else {
            self.reportErrorAtCurrent(message: message)
            return
        }

        self.advance()
    }

    private func match(_ kind: Token.Kind) -> Bool
    {
        guard self.check(kind) else { return false }
        self.advance()
        return true
    }

    private func check(_ kind: Token.Kind) -> Bool
    {
        self.currentToken.kind == kind
    }

    //MARK:- Parsing

    private func expression()
    {
        self.parse(fromPrecedence: .assignment)
    }

    private func declaration()
    {
        if self.match(.var) {
            self.variableDeclaration()
        }
        else {
            self.statement()
        }

        if self.state == .panic {
            self.synchronize()
        }
    }

    private func statement()
    {
        if self.match(.print) {
            self.printStatement()
        }
        else {
            self.expressionStatement()
        }
    }

    private func printStatement()
    {
        self.expression()
        self.mustConsume(.semicolon, message: "Expected ';' to terminate 'print' statement")
        self.emitBytes(for: .print)
    }

    private func expressionStatement()
    {
        self.expression()
        self.mustConsume(.semicolon, message: "Expected ';' to terminate expression")
        self.emitBytes(for: .pop)
    }

    private func variableDeclaration()
    {
        let name = self.parseVariable(failureMessage: "Expected a variable name")
        let declarationLine = self.previousToken.lineNumber

        if self.match(.equal) {
            self.expression()
        }
        else {
            self.emitBytes(for: .nil)
        }
        self.mustConsume(.semicolon, message: "Expected ';' to terminate variable declaration")

        if case let .number(existingIndex)? = self.identifiers.value(for: name) {
            self.chunk.write(operation: .defineGlobal,
                              argument: Int(existingIndex),
                                  line: declarationLine)
        }
        else {
            let index = self.emitConstant(value: .object(name.asBaseRef()),
                                      operation: .defineGlobal,
                                           line: declarationLine)
            guard let newIndex = index else { return }
            self.identifiers.insert(.number(Double(newIndex)), for: name)
        }
    }

    private func parseVariable(failureMessage: String) -> StringRef
    {
        self.mustConsume(.identifier, message: failureMessage)
        return self.previousToken.lexeme.withCStringBuffer(self.copyOrInternString(_:))
    }

    /**
     Consume and handle tokens from the stream as long as the precedence rank of encountered
     tokens is higher than the starting `precedence`.
     */
    private func parse(fromPrecedence precedenceLimit: ParseRule.Precedence)
    {
        self.advance()

        // Compile the initial segment of the current expression
        guard let prefixParser = self.parseRule(for: self.previousToken.kind).prefix else {
            self.reportError(message: "Expected expression.")
            return
        }

        let canAssign = precedenceLimit <= .assignment
        prefixParser(canAssign)

        // Compile the remainder of the expression if the current token is an infix operation
        // of some kind and has sufficiently high precedence.
        var nextRule = self.parseRule(for: self.currentToken.kind)
        while precedenceLimit <= nextRule.precedence {
            self.advance()

            guard let infixParser = nextRule.infix else {
                fatalError("Misconfigured rule table: \(self.previousToken.kind) should have an infix rule")
            }

            infixParser()

            nextRule = self.parseRule(for: self.currentToken.kind)
        }
    }

    private func binary()
    {
        let operatorKind = self.previousToken.kind

        // Compile the right operand (will continue unless/until a higher precedence op is encountered)
        let precedence = self.parseRule(for: operatorKind).precedence
        self.parse(fromPrecedence: precedence.incremented())

        switch operatorKind {
            case .bangEqual: self.emitBytes(for: .equal, .not)
            case .equalEqual: self.emitBytes(for: .equal)
            case .greater: self.emitBytes(for: .greater)
            case .greaterEqual: self.emitBytes(for: .less, .not)
            case .less: self.emitBytes(for: .less)
            case .lessEqual: self.emitBytes(for: .greater, .not)
            case .minus: self.emitBytes(for: .subtract)
            case .plus: self.emitBytes(for: .add)
            case .star: self.emitBytes(for: .multiply)
            case .slash: self.emitBytes(for: .divide)
            default:
                fatalError("Token had non-binary Kind '\(operatorKind)'")
        }
    }

    private func literal()
    {
        switch self.previousToken.kind {
            case .nil:
                self.emitBytes(for: .nil)
            case .true:
                self.emitBytes(for: .true)
            case .false:
                self.emitBytes(for: .false)
            default:
                fatalError("Token is not a literal: \(self.previousToken)")
        }
    }

    private func grouping()
    {
        self.expression()
        self.mustConsume(.rightParen, message: "Expected ')' after expression.")
    }

    private func number()
    {
        guard let value = Double(self.previousToken.lexeme) else {
            fatalError("Failed to convert token '\(self.previousToken.lexeme)' to a Value")
        }
        self.emitConstant(value: .number(value), operation: .constant)
    }

    private func unary()
    {
        let operatorKind = self.previousToken.kind

        self.parse(fromPrecedence: .unary)

        switch operatorKind {
            case .bang: self.emitBytes(for: .not)
            case .minus: self.emitBytes(for: .negate)
            default:
                fatalError("Token had non-unary Kind '\(operatorKind)'")
        }
    }

    private func variable(_ canAssign: Bool)
    {
        self.namedVariable(canAssign)
    }

    private func namedVariable(_ canAssign: Bool)
    {
        let name = self.previousToken.lexeme
            .withCStringBuffer(self.copyOrInternString(_:))
        let identifierLine = self.previousToken.lineNumber

        let operation: OpCode
        if self.match(.equal) {
            guard canAssign else {
                return self.reportError(at: self.previousToken,
                                   message: "Invalid assignment target")
            }
            self.expression()
            operation = .setGlobal
        }
        else {
            operation = .readGlobal
        }

        self.emitConstant(value: .object(name.asBaseRef()),
                      operation: operation,
                           line: identifierLine)
    }

    private func string()
    {
        let lexeme = self.previousToken.lexeme
        // Drop quote marks
        let firstCharIndex = lexeme.index(after: lexeme.startIndex)
        let endQuoteIndex = lexeme.index(lexeme.endIndex, offsetBy: -1)
        let contents = lexeme[firstCharIndex..<endQuoteIndex]

        // We incur an unnecessary copy into a temporary here when the string has no
        // escapes. This matches the Wren implementation (wren_compiler.c -> readString)
        // so we won't worry about it for now. At some point, though, it would be good
        // to compare the performance of scanning the string for backslashes first and
        // skipping rendering if it's not needed -- we'd get a pointer to the String's
        // contents (`withCString`) and copy from that directly.
        do {
            let object: StringRef = try self.stringCompiler.withRenderedEscapes(in: contents,
                                                                                self.copyOrInternString(_:))
            self.emitConstant(value: .object(object.asBaseRef()))
        }
        catch let error as StringEscapeError {
            self.reportError(message: error.message)
        }
        catch {
            assertionFailure("Unexpected error from string compilation: '\(error)'")
            self.reportError(message: "Could not compile string contents: '\(error)'")
        }
    }

    /**
     Look up the given string in the global `strings` table and return the
     existing instance if found; otherwise initialize and return a new
     `StringRef`, inserting it into `strings` first.
     */
    private func copyOrInternString(_ string: ConstCStr) -> StringRef
    {
        if let existing = self.strings.findString(matching: string) {
            return existing
        }
        else {
            let new = self.allocator.createString(copying: string)
            self.strings.internString(new)
            return new
        }
    }

    //MARK:- Chunk handling

    private func emitReturn()
    {
        self.emitBytes(for: .return)
    }

    @discardableResult
    private func emitConstant(value: Value, operation: OpCode = .constant, line: Int? = nil) -> Int?
    {
        let index = self.chunk.write(constant: value,
                                    operation: operation,
                                         line: line ?? self.previousToken.lineNumber)
        if index == nil {
            self.reportError(message: "Constant storage limit exceeded.")
        }

        return index
    }

    private func emitBytes(for opCodes: OpCode..., line: Int? = nil)
    {
        for code in opCodes {
            self.chunk.write(opCode: code, line: line ?? self.previousToken.lineNumber)
        }
    }

    //MARK:- Error handling

    /**
     Scan and discard tokens until an apparent statement boundary, then
     reset the `state` from `.panic`.
     */
    private func synchronize()
    {
        defer { self.state.synchronize() }
        while self.currentToken.kind != .EOF {
            // We want to restart at the beginning of the next statement-like thing,
            // which means the token _after_ a semicolon...
            guard self.previousToken.kind != .semicolon else { return }

            switch self.currentToken.kind {
                // or _on_ an appropriate keyword.
                case .class, .fun, .var, .for, .if, .while, .print, .return:
                    return
                default:
                    break
            }

            self.advance()
        }
    }

    private func reportErrorAtCurrent<S : StringProtocol>(message: S)
    {
        self.reportError(at: self.currentToken, message: message)
    }

    private func reportError<S : StringProtocol>(message: S)
    {
        self.reportError(at: self.previousToken, message: message)
    }

    private func reportError<S : StringProtocol>(at token: Token, message: S)
    {
        guard self.state != .panic else { return }

        self.state.recordError()

        let location: String
        switch token.kind {
            case .EOF: location = " at end"
            case .error: location = ""
            default: location = " at '\(token.lexeme)'"
        }

        StdErr.print("\(token.lineNumber): error:\(location) \(message)")
    }
}

/** Description of handling for a particular token kind. */
private struct ParseRule
{
    enum Precedence : CaseIterable, Comparable
    {
        case none, assignment, or, and, equality, comparison, term, factor, unary, call, primary

        func incremented() -> Precedence
        {
            let cases = Self.allCases
            let index = cases.firstIndex(of: self)!
            let nextIndex = cases.index(after: index)
            guard nextIndex != cases.endIndex else { return .primary }
            return cases[nextIndex]
        }
    }

    /**
     A `Compiler` method that parses an expression where assignments can be handled.
     - parameter canAssign: Whether the current parsing context is permitted to be part of
     an assignment statement (either a variable or an object setter).
     */
    typealias AssignmentParseFunc = (_ canAssign: Bool) -> Void
    /**
     A `Compiler` method that parses an expression where assignments are not
     syntactically allowed.
     */
    typealias ParseFunc = () -> Void

    /**
     Parsing method to be called when the token is found at the beginning of an expression.
     - remark: Most parse methods actually do not need the `canAssign` flag; it will be
     swallowed in that case (see `init(nonassigningPrefix:infix:precedence:)`
     */
    let prefix: AssignmentParseFunc?
    /** Parsing method to be called when the token is found inside an expression. */
    let infix: ParseFunc?
    /**
     Infix precedence for the token, controlling how much of the token stream will be parsed
     into the operand.
     */
    let precedence: Precedence
}

private extension Compiler
{
    func parseRule(for kind: Token.Kind) -> ParseRule
    {
        // Note that any rule lacking an infix parser will also have the lowest possible precedence
        switch kind {
            case .leftParen    : return ParseRule(nonassigningPrefix: self.grouping, infix: nil, precedence: .call)
            case .rightParen   : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .leftBrace    : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .rightBrace   : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .comma        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .dot          : return ParseRule(prefix: nil, infix: nil, precedence: .call)
            case .semicolon    : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .minus        : return ParseRule(nonassigningPrefix: self.unary, infix: self.binary, precedence: .term)
            case .plus         : return ParseRule(prefix: nil, infix: self.binary, precedence: .term)
            case .slash        : return ParseRule(prefix: nil, infix: self.binary, precedence: .factor)
            case .star         : return ParseRule(prefix: nil, infix: self.binary, precedence: .factor)
            case .bang         : return ParseRule(nonassigningPrefix: self.unary, infix: nil, precedence: .none)
            case .bangEqual    : return ParseRule(prefix: nil, infix: self.binary, precedence: .equality)
            case .equal        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .equalEqual   : return ParseRule(prefix: nil, infix: self.binary, precedence: .equality)
            case .greater      : return ParseRule(prefix: nil, infix: self.binary, precedence: .comparison)
            case .greaterEqual : return ParseRule(prefix: nil, infix: self.binary, precedence: .comparison)
            case .less         : return ParseRule(prefix: nil, infix: self.binary, precedence: .comparison)
            case .lessEqual    : return ParseRule(prefix: nil, infix: self.binary, precedence: .comparison)
            case .identifier   : return ParseRule(prefix: self.variable, infix: nil, precedence: .none)
            case .string       : return ParseRule(nonassigningPrefix: self.string, infix: nil, precedence: .none)
            case .number       : return ParseRule(nonassigningPrefix: self.number, infix: nil, precedence: .none)
            case .and          : return ParseRule(prefix: nil, infix: nil, precedence: .and)
            case .break        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .class        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .else         : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .false        : return ParseRule(nonassigningPrefix: self.literal, infix: nil, precedence: .none)
            case .for          : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .fun          : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .if           : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .nil          : return ParseRule(nonassigningPrefix: self.literal, infix: nil, precedence: .none)
            case .or           : return ParseRule(prefix: nil, infix: nil, precedence: .or)
            case .print        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .return       : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .super        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .this         : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .true         : return ParseRule(nonassigningPrefix: self.literal, infix: nil, precedence: .none)
            case .unless       : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .until        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .var          : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .while        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .error        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .EOF          : return ParseRule(prefix: nil, infix: nil, precedence: .none)
        }
    }
}

private extension ParseRule
{
    /** Create a parse rule for a token type that does not need the `canAssign` flag. */
    init(nonassigningPrefix: ParseFunc?, infix: ParseFunc?, precedence: Precedence)
    {
        // Ignore the boolean `canAssign` flag
        self.prefix = nonassigningPrefix.map({ (parse) in { (_) in parse() } })
        self.infix = infix
        self.precedence = precedence
    }
}

private extension Compiler.State
{
    /** Change the state to reflect a parse error having been encountered. */
    mutating func recordError()
    {
        switch self {
            case .normal, .error:
                self = .panic
            case .panic:
                return
        }
    }

    /** If currently in panic mode, return to reporting errors. */
    mutating func synchronize()
    {
        switch self {
            case .normal, .error:
                return
            case .panic:
                self = .error
        }
    }
}

private extension Token
{
    /** Placeholder token for the compiler state before compilation begins. */
    static var dummy: Token
    {
        return Token(kind: .EOF, lexeme: "not a token", lineNumber: -1)
    }
}

private extension StringProtocol
{
    /**
     Invoke `body` with a buffer pointer to the NUL-terminated UTF-8 contents
     of the string.
     - remark: The buffer's `count` includes the NUL character.
     */
    func withCStringBuffer<Result>(_ body: (ConstCStr) -> Result) -> Result
    {
        self.withCString { (chars) -> Result in
            body(ConstCStr(start: chars, count: self.utf8.count + 1))
        }
    }
}
