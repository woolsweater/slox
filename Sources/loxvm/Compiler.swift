import Foundation
import loxvm_object

/**
 Translator from a token stream to bytecode stored in a `Chunk`, using a `Scanner` as a helper
 to get tokens from the provided source.
 */
class Compiler
{
    /** Description of current parsing with regard to error tokens and reporting. */
    fileprivate enum State
    {
        /** Compilation is proceeding without error. */
        case normal
        /**
         Compilation is continuing but an error was previously encountered. We will report as
         many further errors as possible, but discard generated bytecode without executing it.
         */
        case error
        /**
         We've just encountered an error and parsing is in an indeterminate state; error
         messages will be suppressed until we reach a synchronization point.
         */
        case panic
    }
    private var state: State = .normal

    private let scanner: Scanner
    private let allocator: MemoryManager
    private lazy var stringCompiler = StringCompiler(allocate: { self.allocator.allocateBuffer(of: UInt8.self, count: $0) },
                                                      destroy: { self.allocator.destroyBuffer($0) })
    private var currentToken: Token = .dummy
    private var previousToken: Token = .dummy

    private var chunk: Chunk = Chunk()

    /**
     Create a compiler to operate on the given source, obtaining any neccessary heap memory
     from the provided allocator.
     */
    init(source: String, allocator: MemoryManager)
    {
        self.scanner = Scanner(source: source)
        self.allocator = allocator
    }
}

extension Compiler
{
    /** Translate the source into bytecode. */
    func compile() -> Chunk?
    {
        self.advance()
        self.expression()
        self.mustConsume(.EOF, message: "Expected end of expression.")

        guard self.state == .normal else {
            return nil
        }

        self.end()

        return self.chunk
    }

    private func end()
    {
        self.emitReturn()

        #if DEBUG_PRINT_CHUNK
        if self.state == .normal {
            disassemble(self.chunk, name: "generated_code")
        }
        #endif
    }

    /**
     Store the current token, then move past any error tokens, reporting them as appropriate.
     */
    private func advance()
    {
        self.previousToken = self.currentToken

        self.currentToken = self.scanner.scanToken()
        while self.currentToken.kind == .error {
            self.reportErrorAtCurrent(message: self.currentToken.lexeme)
            self.currentToken = self.scanner.scanToken()
        }
    }

    /**
     Check for a particular token kind at the current position, reporting an error if it is not
     found.
     */
    private func mustConsume(_ kind: Token.Kind, message: String)
    {
        guard self.currentToken.kind == kind else {
            self.reportErrorAtCurrent(message: message)
            return
        }

        self.advance()
    }

    //MARK:- Parsing

    private func expression()
    {
        self.parse(fromPrecedence: .assignment)
    }

    /**
     Consume and handle tokens from the stream as long as the precedence rank of encountered
     tokens is higher than the starting `precedence`.
     */
    private func parse(fromPrecedence precedence: ParsePrecendence)
    {
        self.advance()

        // Compile the initial segment of the current expression
        guard let prefixParser = Compiler.parseRule(for: self.previousToken.kind).prefix else {
            self.reportError(message: "Expected expression.")
            return
        }

        prefixParser(self)()

        // Compile the remainder of the expression if the current token is an infix operation
        // of some kind and has sufficiently high precedence.
        var nextRule = Compiler.parseRule(for: self.currentToken.kind)
        while precedence <= nextRule.precedence {
            self.advance()

            guard let infixParser = nextRule.infix else {
                fatalError("Misconfigured rule table: \(self.previousToken.kind) should have an infix rule")
            }

            infixParser(self)()

            nextRule = Compiler.parseRule(for: self.currentToken.kind)
        }
    }

    private func binary()
    {
        let operatorKind = self.previousToken.kind

        // Compile the right operand (will continue unless/until a higher precedence op is encountered)
        let precedence = Compiler.parseRule(for: operatorKind).precedence
        self.parse(fromPrecedence: precedence.incremented())

        switch operatorKind {
            case .bangEqual: self.emitBytes(for: .equal, .not)
            case .equalEqual: self.emitBytes(for: .equal)
            case .greater: self.emitBytes(for: .greater)
            case .greaterEqual: self.emitBytes(for: .less, .not)
            case .less: self.emitBytes(for: .less)
            case .lessEqual: self.emitBytes(for: .greater, .not)
            case .minus: self.emitBytes(for: .subtract)
            case .plus: self.emitBytes(for: .add)
            case .star: self.emitBytes(for: .multiply)
            case .slash: self.emitBytes(for: .divide)
            default:
                fatalError("Token had non-binary Kind '\(operatorKind)'")
        }
    }

    private func literal()
    {
        switch self.previousToken.kind {
            case .nil:
                self.emitBytes(for: .nil)
            case .true:
                self.emitBytes(for: .true)
            case .false:
                self.emitBytes(for: .false)
            default:
                fatalError("Token is not a literal: \(self.previousToken)")
        }
    }

    private func grouping()
    {
        self.expression()
        self.mustConsume(.rightParen, message: "Expected ')' after expression.")
    }

    private func number()
    {
        guard let value = Double(self.previousToken.lexeme) else {
            fatalError("Failed to convert token '\(self.previousToken.lexeme)' to a Value")
        }
        self.emitConstant(value: .number(value))
    }

    private func unary()
    {
        let operatorKind = self.previousToken.kind

        self.parse(fromPrecedence: .unary)

        switch operatorKind {
            case .bang: self.emitBytes(for: .not)
            case .minus: self.emitBytes(for: .negate)
            default:
                fatalError("Token had non-unary Kind '\(operatorKind)'")
        }
    }

    private func string()
    {
        let lexeme = self.previousToken.lexeme
        // Drop quote marks
        let firstCharIndex = lexeme.index(after: lexeme.startIndex)
        let lastCharIndex = lexeme.index(lexeme.endIndex, offsetBy: -1)
        let contents = lexeme[firstCharIndex..<lastCharIndex]

        // We incur an unnecessary copy into a temporary here when the string has no
        // escapes. This matches the Wren implementation (wren_compiler.c -> readString)
        // so we won't worry about it for now. At some point, though, it would be good
        // to compare the performance of scanning the string for backslashes first and
        // skipping rendering if possible -- we'd get a pointer to the String's
        // contents (`withCString`) and copy from that directly.
        do {
            let object = try self.stringCompiler.withRenderedEscapes(in: contents) {
                self.allocator.createString(copying: $0)
            }
            self.emitConstant(value: .object(object.asBaseRef()))
        }
        catch let error as StringEscapeError {
            self.reportError(message: error.message)
        }
        catch {
            assertionFailure("Unexpected error from string compilation: '\(error)'")
            self.reportError(message: "Could not compile string contents: '\(error)'")
        }
    }

    //MARK:- Chunk handling

    private func emitReturn()
    {
        self.emitBytes(for: .return)
    }

    private func emitConstant(value: Value)
    {
        let success = self.chunk.write(constant: value, line: self.previousToken.lineNumber)
        if !(success) {
            self.reportError(message: "Constant storage limit exceeded.")
        }
    }

    private func emitBytes(for opCodes: OpCode...)
    {
        for code in opCodes {
            self.chunk.write(opCode: code, line: self.previousToken.lineNumber)
        }
    }

    //MARK:- Error reporting

    private func reportErrorAtCurrent<S : StringProtocol>(message: S)
    {
        self.reportError(at: self.currentToken, message: message)
    }

    private func reportError<S : StringProtocol>(message: S)
    {
        self.reportError(at: self.previousToken, message: message)
    }

    private func reportError<S : StringProtocol>(at token: Token, message: S)
    {
        guard self.state != .panic else { return }

        self.state.recordError()

        let location: String
        switch token.kind {
            case .EOF: location = " at end"
            case .error: location = ""
            default: location = " at '\(token.lexeme)'"
        }

        StdErr.print("\(token.lineNumber): error:\(location) \(message)")
    }
}

private extension Compiler
{
    enum ParsePrecendence : Int, Comparable
    {
        case none, assignment, or, and, equality, comparison, term, factor, unary, call, primary

        static func < (lhs: ParsePrecendence, rhs: ParsePrecendence) -> Bool
        {
            return lhs.rawValue < rhs.rawValue
        }

        func incremented() -> ParsePrecendence
        {
            guard self != .primary else { return .primary }
            return ParsePrecendence(rawValue: self.rawValue + 1)!
        }
    }

    /** Description of handling for a particular token kind. */
    struct ParseRule
    {
        /**
         Parsing method to be called when the token is found at the beginning of an expression.
         */
        let prefix: ((Compiler) -> () -> Void)?
        /** Parsing method to be called when the token is found inside an expression. */
        let infix: ((Compiler) -> () -> Void)?
        /**
         Infix precedence for the token, controlling how much of the token stream will be parsed
         into the operand.
         */
        let precedence: ParsePrecendence
    }

    static func parseRule(for kind: Token.Kind) -> ParseRule
    {
        // Note that any rule lacking an infix parser will also have the lowest possible precedence
        switch kind {
            case .leftParen    : return ParseRule(prefix: Compiler.grouping, infix: nil, precedence: .call)
            case .rightParen   : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .leftBrace    : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .rightBrace   : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .comma        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .dot          : return ParseRule(prefix: nil, infix: nil, precedence: .call)
            case .semicolon    : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .minus        : return ParseRule(prefix: Compiler.unary, infix: Compiler.binary, precedence: .term)
            case .plus         : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .term)
            case .slash        : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .factor)
            case .star         : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .factor)
            case .bang         : return ParseRule(prefix: Compiler.unary, infix: nil, precedence: .none)
            case .bangEqual    : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .equality)
            case .equal        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .equalEqual   : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .equality)
            case .greater      : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .comparison)
            case .greaterEqual : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .comparison)
            case .less         : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .comparison)
            case .lessEqual    : return ParseRule(prefix: nil, infix: Compiler.binary, precedence: .comparison)
            case .identifier   : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .string       : return ParseRule(prefix: Compiler.string, infix: nil, precedence: .none)
            case .number       : return ParseRule(prefix: Compiler.number, infix: nil, precedence: .none)
            case .and          : return ParseRule(prefix: nil, infix: nil, precedence: .and)
            case .break        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .class        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .else         : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .false        : return ParseRule(prefix: Compiler.literal, infix: nil, precedence: .none)
            case .for          : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .fun          : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .if           : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .nil          : return ParseRule(prefix: Compiler.literal, infix: nil, precedence: .none)
            case .or           : return ParseRule(prefix: nil, infix: nil, precedence: .or)
            case .print        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .return       : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .super        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .this         : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .true         : return ParseRule(prefix: Compiler.literal, infix: nil, precedence: .none)
            case .unless       : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .until        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .var          : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .while        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .error        : return ParseRule(prefix: nil, infix: nil, precedence: .none)
            case .EOF          : return ParseRule(prefix: nil, infix: nil, precedence: .none)
        }
    }
}

private extension Compiler.State
{
    /** Change the state to reflect a parse error having been encountered. */
    mutating func recordError()
    {
        switch self {
            case .normal, .error:
                self = .panic
            case .panic:
                return
        }
    }

    /** If currently in panic mode, return to reporting errors. */
    mutating func synchronize()
    {
        switch self {
            case .normal, .error:
                return
            case .panic:
                self = .error
        }
    }
}

private extension Token
{
    /** Placeholder token for the compiler state before compilation begins. */
    static var dummy: Token
    {
        return Token(kind: .EOF, lexeme: "not a token", lineNumber: -1)
    }
}
